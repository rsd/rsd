#!/bin/bash

# main support library to RSD

RSD_RSDLIB_VERSION='0.2.0'


# checks if there are the minimun required arguments or call usage
function rsd::arguments_or_usage() {
    local total=$1
    shift

    rsd::debug2 20 "rsd_arguments_or_usage: total arguments: $total, Arguments:" $@
    if [[ "$#" -lt "$total" ]]; then
        rsd::usage
    fi
    return 0
}

# same as rsd::debug, but to STDERR
function rsd::warn() {
    local msg=$1
    shift
    local level=1

    if (($#>0));then
        level=$1
    fi
    if (( $RSD_DEBUG >= $level )); then
        echo "$level:$msg" >&2
    fi
}

# same as rsd::debug2, but to STDERR
function rsd::warn2() {
    local level=$1
    shift

    if (( $RSD_DEBUG >= $level )); then
        echo "$level:" $@ >&2
    fi
}

# locates the command and, if exists, outputs it to STDOUT.
function rsd::check_command() {
    local command

    for command in $1 $1.sh $1.bash $1.cmd $1.rsd; do
        rsd::warn2 10 "Looking for '$1' in $command"
        if [[ -f "$RSD_BASE/command/$command" ]]; then
            echo "$RSD_BASE/command/$command"
            return 0
        fi
    done
    return 1
}

# this outputs the source line to be executed
# it does not execut directly, as this needs to be outsie of a function
function rsd::load_command_file() {
    rsd::arguments_or_usage 1 $@
    local command_with_path
    local command=$1

    command_with_path=$(rsd::check_command $command)

    if (($?)); then
        rsd::warn "Command $command is invalid" 2
        return 1
    fi
    echo source \"$command_with_path\"
    return 0
}


# execute command if any
# looks for the first ocorruence of rsd::<command>::<command> (preferred),
# rsd::<command>, <command> or even main.
function rsd::command() {
    rsd::arguments_or_usage 1 $@
    local command=$1
    local real_command

    for real_command in rsd::$command::$command rsd::$command $command main; do
        if bash::is_function $real_command; then
            rsd::debug "Calling $real_command with arguments: ${RSD_ARGS[subargs]}" 5
            $real_command ${RSD_ARGS[subargs]}
            exit 0
        else
            rsd::generic_command $command
        fi
    done
}

# make an action call
# if no action is given, repeat the command name as an action
function rsd::generic_command() {
    rsd::arguments_or_usage 1 $@
    local command=$1

    rsd::parse_args ${RSD_ARGS[subargs]}
    rsd::generic_action $command ${RSD_ARGS[command]}
}

# call a generic action in command
# pass the subargs in the RSD_ARGS hash
function rsd::generic_action() {
    rsd::arguments_or_usage 2 $@
    local command=$1
    local action=$2
    echo Action $2
    local action_function

    for action_function in rsd::${command}::action::${action} \
        rsd::${command}::${action} rsd::${action} ${command}::${action} $action
    do
        # we need a /g modifier (5 depth)
        action_function=${action_function//-/_}
        action_function=${action_function//-/_}
        action_function=${action_function//-/_}
        action_function=${action_function//-/_}
        action_function=${action_function//-/_}

        if bash::is_function $action_function; then
            rsd::debug "function for action $RSD_ACTION is $action_function" 8
            $action_function ${RSD_ARGS[subargs]}
            exit 0
        fi
    done

    echo "Action $action for command $command does not exist."
    rsd::usage
}

