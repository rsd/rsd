#!/bin/bash

# rsd [rsd options] COMMAND [command options]
# rsd [rsd options] --version
# rsd [rsd options] --check-version
# rsd [rsd options] --install PATH
#
# Description:
#   rsd is a generic command loader from the command line
#
#   for commands, actually, are bash functions.
#   the idea is the group classes of commands (or tasks) into modules
#   and let rsd call it to have a unty experience
#
# rsd options:
#   --debug LEVEL | -d LEVEL
#       set the debug level
#   --lib-dir PATH | -l PATH
#       use PATH as libdir
#   --no-local | -nl
#       do not switch to a local rsd copy
#
# Exit codes:
#   0 - SUCCESS
#   1 - Not bash 4
#   2 - Bad usage
#   3 - Command not found
#   4 - There is a new version in the repository
#   5 - Missing
#   6 - Missing system files (maybe not installed)
#   7 - Mismatch information
#   8 - To be done in the future
#   9 - Missing command line argument
#   10 - Command failure (unknown reason)
#   11 - Internal Failure

RSD_VERSION='0.2.1'
VERSION=$RSD_VERSION

RSD_DEBUG=0
DEBUG=$RSD_DEBUG

# The latest version of this file in the repository url
RSD_GITHUB_REPO="https://github.com/rsd/rsd.git"
RSD_LATEST_RSD_REPO="https://raw.githubusercontent.com/rsd/rsd/master/rsd"

# preserves arguments
RSD_ORIGINAL_ARGS="$0 $@"

# if a function returns error, this is the reason
# TODO: write a better API to handle errors
RSD_ERROR_MSG=""

# base path to libraries
RSD_BASE=""

RSD=$(basename $0)

if [ "${BASH_VERSINFO[0]}" -lt 4 ]; then
    echo "Abort! BASH >= 4 required.  Got $BASH_VESION"
    exit 1
fi

shopt -s extglob

declare -A RSD_ARGS=( ["subargs"]="" ["command"]="" )
# paramenters arguments
# 0 => No argument
# 1 => One argument
# unknown defaults to 1
declare -A RSD_ARGS_PARAM=( ["debug"]=1 ["d"]=1 ["version"]=0 ["check-version"]=0 ["lib-dir"]=1 ["l"]=1\
                            ["install"]=1 ["no-local"]=0 ["nl"]=0 )

function rsd::version_gt() {
    test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1";
}

function rsd::usage() {
    echo "$RSD v$RSD_VERSION"
    echo "Usage:"
    echo -e "\t$RSD <command> [OPTIONS]"
    echo -e "\tCommands:"

    exit 2
    }

function rsd::debug() {
    local msg=$1
    shift
    local level=1

    if (($#>0));then
        level=$1
    fi
    if (( $RSD_DEBUG >= $level )); then
        echo "$level:$msg"
    fi
}

#same as rsd::debug, but the level comes first, for convenience
function rsd::debug2() {
    local level=$1
    shift

    if (( $RSD_DEBUG >= $level )); then
        echo "$level:" $@
    fi
}

#Finds a file in the path
function rsd::check_binary() {
    local file=$1
    local path
    local IFS=":"

    for path in $PATH; do
        if [[ -f "$path/$file" ]]; then
            return 0
        fi
    done

    RSD_ERROR_MSG="Command $file not in PATH."
    return 1
}

function rsd::check_binaries() {
    local file
    local path
    local IFS=":"

    for file in $*;  do
        if ! rsd::check_binary $file; then
            return 1
        fi
    done
    return 0
}

function rsd::check_binaries_or_fail() {
    if ! rsd::check_binaries $@; then
        echo $RSD_ERROR_MSG
        exit 3
    fi
    return 0
}

# for debug, it has to be done in the script, command line does not work so soon
# TODO: make an exception if the argument does not exist
function rsd::parse_args() {
    local arg
    local count=0

    rsd::debug2 8 "rsd::parse_args: Total: $#, Arguments:" $@
    rsd::debug2 8 "rsd::parse_args: RSD_ARGS subargs: " ${RSD_ARGS["subargs"]}

    RSD_ARGS["subargs"]=

    while [ $# -gt 0 ]; do
        case "$1" in
        --*)
            arg=${1:2}
            if bash::key_exists $arg in RSD_ARGS_PARAM; then
                if [[ "${RSD_ARGS_PARAM[$arg]}" == "0" ]]; then
                    RSD_ARGS[${arg,,}]=1
                else
                    if [[ -z $2 ]]; then
                        echo "Abort! Missing argumento to $arg."
                        exit 9
                    fi
                    RSD_ARGS[${arg,,}]=$2
                    shift
                fi
            else
                RSD_ARGS[${arg,,}]=$2
                shift
            fi
            ;;
        -*)
            arg=${1:1}
            if bash::key_exists $arg in RSD_ARGS_PARAM; then
                if [[ "${RSD_ARGS_PARAM[$arg]}" == "0" ]]; then
                    RSD_ARGS[${arg,,}]=1
                else
                    if [[ -z $2 ]]; then
                        echo "Abort! Missing argumento to $arg."
                        exit 9
                    fi
                    RSD_ARGS[${arg,,}]=$2
                    shift
                fi
            else
                RSD_ARGS[${arg,,}]=$2
                shift
            fi
            ;;
        *)
            if ((count == 1)); then
                RSD_ARGS["subargs"]=$*
                shift
                break
            fi
            RSD_ARGS["command"]=$1

            ((count++))
            ;;
        esac
        shift
    done

    local key
    for key in ${!RSD_ARGS[@]}; do
        rsd::debug2 8 "parse_agrs: arguments: $key: ${RSD_ARGS[$key]}"
    done

    return 0
}

# from bash_extensions.lib
function bash::key_exists(){
    if [[ "$2" != "in" ]]; then
        echo "Abort! Incorrect usage of bash::key_exists."
        echo "Correct usage: bash::key_exists {key} in {array}"
        exit 11
    fi
    eval '[ ${'$3'[$1]+muahaha} ]'
}

# check the latest version in the repository
function rsd::check_repository_version() {
    local repo_version
    rsd::check_binaries_or_fail wget grep head

    repo_version=$(wget -q -O - $RSD_LATEST_RSD_REPO | grep ^RSD_VERSION= \
                  | head -n 1 | sed -e "s/.*=['\"]\(.*\)['\"]/\1/")

    if rsd::version_gt $repo_version $RSD_VERSION; then
        RSD_ERROR_MSG="There is a newes version in the repository: $repo_version.  Our version: $RSD_VERSION."
        return 1
    elif [[ $repo_version == $RSD_VERSION ]]; then
        RSD_ERROR_MSG="You are using the latest version: $RSD_VERSION."
    else
        RSD_ERROR_MSG="Your version: $RSD_VERSION is newer that the one in the repository: $repo_version."
    fi

    return 0
}

# locates where our library is.
# the search order is:
#   - argument to the command line,
#   - config, (TODO)
#   - current path,
#   - rsd is a symlink to the library,
#   - in user's home (TODO) and
#   - system wide install (TODO)
function rsd::get_base() {
    rsd::check_binaries_or_fail which readlink dirname pwd

    # arguments
    if   [[ ${RSD_ARGS["lib-dir"]} ]]; then
        RSD_BASE=${RSD_ARGS[lib-dir]}
        rsd::test_libdir
        return $?
    elif [[ ${RSD_ARGS[l]} ]]; then
        RSD_BASE=${RSD_ARGS[l]}
        rsd::test_libdir
        return $?
    fi

    # current path
    RSD_BASE=$(pwd)
    if rsd::test_libdir; then
        return 0
    fi

    # symlink
    RSD_BASE=$(dirname $(readlink -f $0))
    if rsd::test_libdir; then
        return 0
    fi

    return 1
}

# FIXME
function rsd::test_libdir() {
    if [[ -f $RSD_BASE/lib/rsd.lib ]]; then
        return 0
    fi
    return 1
}


# __main__
# FIXME: as a recursive command calling, this is worked outside a function (for now at least)

RSD_ORIGINAL_ARGS="$0 $@"
rsd::parse_args $*

# import rsd::debug level
if   [[ ${RSD_ARGS[debug]} ]]; then
    RSD_DEBUG=${RSD_ARGS[debug]}
elif [[ ${RSD_ARGS[d]} ]]    ; then
    RSD_DEBUG=${RSD_ARGS[d]}
fi
rsd::debug "Debug set to $RSD_DEBUG" 2
rsd::debug2 9 "Arguments parsed (values): keys -> (${RSD_ARGS[@]}): " ${!RSD_ARGS[@]}
rsd::debug "Original call was $RSD_ORIGINAL_ARGS" 7

# swith to a local copy if any (local == pwd)
if [[ ! ${RSD_ARGS[no-local]} || ! ${RSD_ARGS[nl]} ]]; then
    if [[ "$RSD_RUN_DIR" != "$RSD_LOCAL_DIR" ]]; then
        RSD_LOCAL_RSD="$RSD_LOCAL_DIR/$RSD"
        if [[ -x  "$RSD_LOCAL_RSD" ]]; then
            #get version
            RSD_LOCAL_VERSION=$( $RSD_LOCAL_RSD --version)
            if rsd::version_gt $RSD_LOCAL_VERSION $VERSION; then
                echo "Switching to local version (-nl to avoid)."
                $RSD_LOCAL_RSD $@
                exit 0
            fi
        fi
    fi
fi


if ! rsd::get_base; then
    echo "Abort! Could not find libdir.  Maybe it need to be installed --install (TODO)."
    exit 5
fi


# version
if [[ ${RSD_ARGS[version]} ]]; then
    echo $RSD_VERSION
    exit 0
fi

# check version
if [[ ${RSD_ARGS[check-version]} ]]; then
    if ! rsd::check_repository_version; then
        echo $RSD_ERROR_MSG
        exit 4
    else
        echo $RSD_ERROR_MSG
        exit 0
    fi
fi

# downloads and install
# TODO: What to do with the running rsd?
# check version
if [[ ${RSD_ARGS[install]} ]]; then
    rsd::check_binaries_or_fail git
    echo "Installing latest rsd from repository."
    git clone --depth 1 $RSD_GITHUB_REPO ${RSD_ARGS[install]}
fi

# load our main library
# after this point there is a need to the full installation
#Now load our defaults
source "$RSD_BASE/lib/rsd.lib"

if [[ -f "$RSD_BASE/lib/bash_extensions.lib" ]]; then
    source "$RSD_BASE/lib/bash_extensions.lib"
else
    echo "Abort! Missing bash extensions library."
    exit 5
fi


if [[ -z "${RSD_ARGS[command]}" ]]; then
    echo "Abort! No COMMAND specified."
    rsd::usage
fi
RSD_COMMAND=${RSD_ARGS[command]}

# import the calling command script
eval $(rsd::load_command_file  $RSD_COMMAND)
if [[ "$?" != "0" ]]; then
	echo "Command $RSD_COMMAND not found"
	rsd::usage
fi


# FIXME: for now
exit 0
